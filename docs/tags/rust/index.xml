<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Rust - 标签 - 闲云的博客</title>
    <link>http://cxz888.xyz/tags/rust/</link>
    <description>Rust - 标签 - 闲云的博客</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Aug 2022 23:42:42 &#43;0800</lastBuildDate><atom:link href="http://cxz888.xyz/tags/rust/" rel="self" type="application/rss+xml" /><item>
  <title>在 Rust 中表征树形结构</title>
  <link>http://cxz888.xyz/posts/tech/tree_in_rust/</link>
  <pubDate>Sun, 14 Aug 2022 23:42:42 &#43;0800</pubDate>
  <author>cxz888</author>
  <guid>http://cxz888.xyz/posts/tech/tree_in_rust/</guid>
  <description><![CDATA[<p>树形结构在软件中相当常用。比如文件目录、右键菜单、多级收藏夹等。</p>
<p>在其它语言，如 C/C++ 中，表达树形结构可能仅需要指针即可，然而在 Rust 中需要稍费周折。</p>
<p><figure><a class="lightgallery" href="/images/tree_eg_content.png" title="树示例" data-thumbnail="/images/tree_eg_content.png" data-sub-html="<h2>Hugo 文章结构</h2><p>树示例</p>">
    
  </a><figcaption class="image-caption">Hugo 文章结构</figcaption>
  </figure></p>
<p>众所周知，Rust 中想要实现一个足够通用的双向链表并不是容易事，其根本原因是所有权机制。</p>
<p>在链表这样底层的数据结构中，所有权关系往往并没有那么明确。对于树来说也是同样。</p>
<p>下面我来尝试梳理一些解决方案。</p>
<h2 id="应用场景">应用场景</h2>
<p>首先来假定一个简单的应用场景吧。</p>
<p><figure><a class="lightgallery" href="/images/adobe_acrobat_csapp_catalog.png" title="Acrobat 书签" data-thumbnail="/images/adobe_acrobat_csapp_catalog.png" data-sub-html="<h2>Acrobat 书签，CSAPP 目录</h2><p>Acrobat 书签</p>">
    
  </a><figcaption class="image-caption">Acrobat 书签，CSAPP 目录</figcaption>
  </figure></p>
<p>假设我们希望实现 Acrobat 这样的多级书签功能，并且需要可以修改：包括增删改书签、调整顺序、调整级别。</p>
<p>这是一个广义的非二叉树结构。或者更准确点是个森林结构，因为顶级标签并无父节点，不过这无伤大雅。</p>
<p>总之抽象出来的需求就是：</p>
<ol>
<li>除根节点外，每个节点具有一个父节点</li>
<li>每个节点可以具有多个子节点，也可以没有</li>
<li>节点具有数据值（在这里是标签名）</li>
</ol>
<h2 id="1-递归数据结构">1. 递归数据结构</h2>
<h3 id="定义">定义</h3>
<p>我们用 <code>Item</code> 代表每一个标签项。</p>
<p>一个优美而非常具有诱惑力的想法是朴素的递归数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>顺便一提，如果希望树是异构的，比如需要在类型系统上区分内节点和叶节点，可以使用 <code>enum</code></p>
</blockquote>
<p>非常简单。而如果希望遍历整个树，代码也非常简洁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">child</span><span class="p">.</span><span class="n">walk</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这已经是几乎不能再短的代码量了。</p>
<h3 id="缺点">缺点</h3>
<p>然而这种简洁背后其实隐含的信息是：每个 <code>Item</code> 完整拥有其子节点的所有权。</p>
<p>或者说，任何一个子节点，都被看作是父节点的一部分。这意味一旦发生借用，将会影响到整个父节点。</p>
<p>比如说我需要根据节点的名称找到该节点，函数的签名可能类似于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">look_for</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">todo!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里返回的 <code>Item</code> 的引用可能需要暂存起来，之后再使用来做某些事。然而既然是引用，就需要服从 Rust 的所有权机制。</p>
<p>也就是说，这时候从根开始的整个树是不可变的。这显然极大地妨碍了可进行的操作。</p>
<p>更何况，有时候我们需要返回特定节点的可变引用，以待进行操作，如进行重命名等。</p>
<p>以书签为例，我们可能需要在发生鼠标事件时选中某个标签。也就是返回其引用。而直到很长一段时间之后，我可能忽然需要将它重命名，那么先前返回的就得是可变引用。</p>
<p>而在这段时间之内，就连不可变借用都无法发生。</p>

<p>更糟糕的是，假如我需要调整某个标签的位置呢？如果是在同一层调整先后顺序，那就必须要获取父节点的可变引用，调整其 <code>children</code> 字段。</p>
<p>这几乎是不可完成的。所以需要换个思路。</p>
<h3 id="变通方法">变通方法</h3>
<p>在换思路之前我们先来看看有没有一些（不优雅的）修补方法。</p>
<p>上述方法之所以不可用，是因为试图用引用来访问某个特定的节点。</p>
<p>既然如此，干脆不引用得了。最极端的方法：每次需要进行操作我都从根节点朝下遍历找到需要的节点。</p>
<p>在节点较少时，这种方案还算可以接受，毕竟代码比较容易写。</p>
<p>另一种稍微优化的方案是，对于每个节点，使用从根到其路径来代表它。</p>
<p>具体而言就是，用一个 <code>Vec&lt;usize&gt;</code> 记录路径，表示“根节点的第 x 个子节点的第 y 个子节点的&hellip;”。</p>
<p>如下述结构，其中 <code>life</code> 节点可以用 <code>[1,0]</code> 表示，代表它是根节点 <code>content</code> 的第 1 个子节点 <code>categories</code> 的第 0 个子节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">content
</span></span><span class="line"><span class="cl">├── about.md
</span></span><span class="line"><span class="cl">└── categories
</span></span><span class="line"><span class="cl">   ├── life
</span></span><span class="line"><span class="cl">   └── tech
</span></span></code></pre></td></tr></table>
</div>
</div><p>在大部分情况下，树形结构的深度都不会太夸张，那么这个方案也是可以接受的。</p>
<p>不过需要注意的是，路径随时可能失效。比如我有一天忽然删除了 <code>about.md</code> 这个节点，那么 <code>categories</code> 就变成了 <code>content</code> 的第 0 个子节点了。</p>
<h2 id="2-内部可变性与共享所有权">2. 内部可变性与共享所有权</h2>
<h3 id="定义-1">定义</h3>
<p>朴素方法的核心矛盾在于，无法长久保存一个节点的可变引用。</p>
<p>此时我们就得想办法绕过 Rust 的借用检查机制了。</p>
<p>比如使用 <a
  href="https://doc.rust-lang.org/std/rc/struct.Rc.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
><code>Rc</code></a> 共享所有权，以及使用 <a
  href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
><code>RefCell</code></a> 获得内部可变性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>用 <code>Rc</code> 是必不可少的，因为 <code>RefCell</code> 并非完全避开借用检查，只是将编译时运行检查推迟到运行时而已。这也意味着仍然无法同时持有可变引用和不可变引用。</p>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">root</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_example</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">item_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root</span><span class="p">.</span><span class="n">borrow</span><span class="p">().</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">root</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">children</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第 2 行借用了 1 号子节点，然而第 3 行却又操作了子节点数组，这个过程无可避免地用到了可变借用，于是发生了运行时错误：<code>thread 'refcell::lab::test' panicked at 'already borrowed: BorrowMutError'</code>。</p>
<p>为了保证节点的生命周期，我们需要用 <code>Rc</code> 来共享所有权。</p>
<p>除去对子节点的引用外，我们还需要保留对父节点的引用，以方便某些操作（如调整某节点在父节点列表中的顺序）。</p>
<p>然而，这里却不可以再采取 <code>Rc</code> 的方法了，原因是形成了循环引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">parent</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于根节点可以没有父节点，所以采用 <code>Option</code> 包装了 <code>parent</code> 字段。</p>
<p>以上结构在 Rust 中是合法的。然而它其实因为循环引用而发生了内存泄露，如需证明，可以运行以下代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="s">&#34;l1&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">parent</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="s">&#34;l2&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">parent</span>: <span class="nb">Some</span><span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="n">clone</span><span class="p">()),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">l1</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">children</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">l2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">l1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这会输出无穷无尽的内容，直到编译器报错 <code>thread 'refcell::lab::test' has overflowed its stack</code> 并退出。</p>
<p>稍微分析以下就知道，子节点 <code>l2</code> 引用了父节点 <code>l1</code>，而 <code>l1</code> 又引用了 <code>l2</code>，这样的循环引用导致循环计数永不归零，发生内存泄漏。</p>
<p>为了避免这个问题，需要使用弱引用 <a
  href="https://doc.rust-lang.org/std/rc/struct.Weak.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
><code>Weak</code></a>。</p>
<blockquote>
<p>其实不是用弱引用也是可以的，只需要手动实现 <code>Drop</code> trait，在析构时手动解除引用即可——<code>Rc</code> 循环引用的问题在于它不是自动析构的</p>
<p>另外提一点，递归结构的默认析构可能会导致递归析构，因而栈溢出。为了避免这种情况也可以手动实现 <code>Drop</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 为了方便起个短的别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">type</span> <span class="nc">Parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">type</span> <span class="nc">ItemRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">parent</span>: <span class="nc">Parent</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ItemRef</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>值得一提的是，这里 <code>Parent</code> 类型可以不用包装为 <code>Option</code>，因为 <code>Weak</code> 本身也是可以指向空的。</p>
<p>还是以遍历和获取特定节点为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">child</span><span class="p">.</span><span class="n">borrow</span><span class="p">().</span><span class="n">walk</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">look_for</span><span class="p">(</span><span class="n">item</span>: <span class="kp">&amp;</span><span class="nc">ItemRef</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">ItemRef</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">borrow</span><span class="p">().</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">.</span><span class="n">borrow</span><span class="p">().</span><span class="n">children</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span>::<span class="n">look_for</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">ret</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>walk</code> 的实现大差不大，由于智能指针的 <code>Deref</code> trait，只需要加上一个 <code>.borrow()</code> 即可。而 <code>look_for</code> 的 API 稍微改了一下，没有以 <code>&amp;self</code> 为第一参数，而是 <code>&amp;ItemRef</code>。这是为了方便 <code>clone</code> 出 <code>Rc</code> 返回给调用者。</p>
<p>如果希望以 <code>&amp;self</code> 为参数，作为类型的方法的话，可能需要另外的一个 <code>struct</code> 封装，这里不细讲了。</p>
<p>这个方案还有一个好处在于它可以轻松转换为线程安全的版本：只需将 <code>Rc</code> 改为 <code>Arc</code>，<code>RefCell</code> 改为 <code>RwLock</code> 或 <code>Mutex</code> 即可。当然内部实现也需要略微变化，不过概念上基本保持一致。</p>
<p>而 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 的类型本来也就是多线程编程中常用的。</p>
<h3 id="缺点-1">缺点</h3>
<p>这个方案已经足够满足我们的需求了。在持有父节点引用的情况下，无论是调整节点的顺序或者层级都是可行的。而 <code>Rc</code> 又允许我们长久地保存节点，对于重命名等场景也足够好用。</p>
<p>硬要说缺点的话一个是类型的包装比较复杂，如果直接向外界提供接口会暴露很多实现细节。而如果希望封装这些细节则少不了一些样板代码。</p>
<p>另一个是无法方便地集成 <code>serde</code> 进行序列化和反序列化。这是因为 <code>Rc</code> 没有实现 <code>Serialize</code> 和 <code>Deserialize</code>。而且由于涉及到引用的问题，父节点和子节点之间具有依赖关系，必须先后创建。</p>
<p>还有一个就是 <code>RefCell</code> 和 <code>Rc</code> 的运行时开销问题。<code>RefCell</code> 会进行运行时的借用检查，而 <code>Rc</code> 需要维护引用计数，二者都具有一定的开销，总体来说是不如朴素方案的。</p>
<p>思考这些，说到底还是所有权和引用的问题。</p>
<p><code>RefCell</code> 说是避开了编译器检查，但实际上还是免不了运行时检查。</p>
<p>而 <code>Rc</code> 的共享所有权也仍然没有改变节点之间的依赖关系：父节点仍然是拥有子节点的，而子节点也弱引用着父节点。只不过在这种方案下，由于 <code>Rc</code> 的存在，可以创造出临时或长期的其它变量拥有某个节点的所有权。</p>
<p>而下一个方案则是用巧妙的方法更改了所有权的结构，并且避开了引用。</p>
<h2 id="3-arena">3. Arena</h2>
<blockquote>
<p>这个方法我最初是在<a
  href="https://developerlife.com/2022/02/24/rust-non-binary-tree/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>这篇文章</a>中看到的。</p>
</blockquote>
<p>Arena 意为竞技场、大舞台等。关于其在计算机科学中的定义可以参考 <a
  href="https://en.wikipedia.org/wiki/Region-based_memory_management"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>wiki</a>。</p>
<p>简单而言，它就是一块较大的内存空间，我们将所需的数据存放在这块空间中，而非需要时再向操作系统申请。</p>
<p>首先，我们先定义 <code>Arena</code> 和 <code>Item</code> 结构体。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Arena</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">Item</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">parent</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Arean</code> 就是包装一下 <code>HashMap</code>，它将 <code>usize</code> 映射到某个 <code>Item</code> 上面。这里可以将 <code>usize</code> 理解为 ID。也就是说，我们给每个 <code>Item</code> 一个独一无二的编号，类似于数据库中的主键。</p>
<p>这种编号一经确定不再更改，那么在之后的任何时刻，都可以用一个廉价的 <code>usize</code> 来指代一个 <code>Item</code>，直到需要使用时再从 <code>Arena</code> 中查询即可。</p>
<p>常做算法题或者参与过竞赛的同学应该在图论、树等题目中见过类似的表示。这些题目中往往用节点编号直接表示节点。而且由于题目常常不涉及到删除，可以直接用数组存储，不像这里需要考虑复杂的增删改查所以使用了哈希表。</p>
<p>理解这个之后再看 <code>Item</code>，显然，现在 <code>parent</code> 也通过一个 <code>usize</code> 来表示，当然因为可以没有父节点所以包装为 <code>Option</code>。而 <code>children</code> 子节点列表也可以用 <code>Vec&lt;usize&gt;</code> 表示。</p>
<p>在这种写法下，遍历和查找可以如此表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 这里是作为 `Arena` 的方法
</span></span></span><span class="line"><span class="cl"><span class="c1">// 实际实现不一定采取这样的接口
</span></span></span><span class="line"><span class="cl"><span class="c1">// 比如可以实现为 `Item` 的方法，并以 `Arena` 为参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="o">&amp;</span><span class="n">curr</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">walk</span><span class="p">(</span><span class="o">*</span><span class="n">child</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">look_for</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="o">&amp;</span><span class="n">curr</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">look_for</span><span class="p">(</span><span class="o">*</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">ret</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>思考一下 <code>Arena</code> 这种方法的本质。它实际上让所有权结构由原来的树形结构变为了依托于 <code>HashMap</code> 的平铺结构，然后不通过引用或者 <code>RefCell</code> 等进行索引，而是使用廉价的 ID 作为代表，这也是某种意义上的引用。</p>
<p>由于这里的所有类型都是比较平常的，因此它可以轻松集成 <code>serde</code>。而如果需要多线程，则使用并发原语保护 <code>Arena</code> 即可。</p>
<p>不过这里其实有一些微妙之处：<code>children</code> 中的 <code>usize</code> 可以重复吗？一般而言不会想让它重复，所以我们可以用 <code>HashSet</code> 或 <code>BTreeSet</code> 来代替 <code>Vec</code>。</p>
<p>但这样的修改又会带来一些微妙之处：在类似于书签这样的应用场景下，我们希望子节点是有序的。<code>HashSet</code> 显然无序，而 <code>BTreeSet</code> 虽然有序，却是根据键值决定的顺序，不修改键值也就是 ID 就无法调整顺序。因此这里使用了第三方库 <a
  href="https://docs.rs/indexmap/1.9.1/indexmap/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
><code>indexmap</code></a> 中的 <a
  href="https://docs.rs/indexmap/1.9.1/indexmap/set/struct.IndexSet.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
><code>IndexSet</code></a> 来同时保证唯一性和有序性。</p>
<h2 id="总结">总结</h2>
<p>仔细思考，在朴素的方案中，由于递归数据结构，它天然就保证了节点的有序性，而且从类型系统上就保证了它是严格的树形结构。</p>
<p>至于使用 <code>Rc</code> 和 <code>RefCell</code> 的方式，其实是完全可以用其表示链表结构——有点像一棵退化的树，也可以表示更复杂的图结构——然而这种情况下极易发生循环引用而引发内存泄露。</p>
<p><code>Arena</code> 的方案其实也无法保证一定是树形结构，不过反过来说，它也可以轻易扩展成更复杂的图结构，而且也不会有内存问题。</p>
<p>从使用的难易程度来看，递归数据结构和 <code>Arena</code> 都比较简单灵活，而 <code>Rc</code>+<code>RefCell</code> 的方式则需要多加注意。</p>
<p>而性能层面我没有具体计算和测试过，不过 <code>Arena</code> 中有诸多 <code>Hash</code> 和索引操作，所以可能是有不少额外开销的。<code>Rc</code>+<code>RefCell</code> 的方式也许略好，而如果是简单遍历，那么朴素方法应当是最好的。</p>
<p>其实除去这些之外，还有一个终极方案是 <code>unsafe</code>。事实上我个人觉得这种底层数据结构才是 <code>unsafe</code> 大展拳脚的地方。更上层的领域中所有权和借用等概念则是很好的帮手。因为 <code>unsafe</code> 有许多需要注意的点，我本人也没有太深入接触过，因此这里就不详细写了。</p>
<p>面对 <code>unsafe</code> 的一个基本态度是：先假定 safe 可以解决问题，待到实在不可行时才考虑 <code>unsafe</code>。</p>
<p>感谢阅读。</p>
<blockquote>
<p>2022/10/9 更新：</p>
<p>前段时间看了 <a
  href="https://rust-unofficial.github.io/too-many-lists/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Too Many List</a> 这本书，颇为相见恨晚。作者深入浅出地解析了 Rust 中链表的各种写法，最终实现了一个生产级别的 Unsafe 双向链表。</p>
<p>无论是作为 Unsafe Rust 的入门书还是解决树形结构问题都是很好的参考书籍，推荐阅读。当然，也有些体会到 Unsafe 代码写起来战战兢兢的感觉，还是 Safe Rust 舒适 :D</p>
<p>另外，我在 <a
  href="https://crates.io"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>crates.io</a> 上发现了 <a
  href="https://crates.io/crates/slab"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>slab</a> 这个库，感觉可以一定程度上作为 Arena 方案来使用。</p>
</blockquote>
<blockquote>
<p>版权声明：本文采用 <a
  href="http://creativecommons.org/licenses/by/4.0/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>CC BY 4.0</a> 进行许可，转载请注明出处。</p>
<p>本文链接：<a
  href="http://cxz888.xyz/posts/tech/tree_in_rust/"
  
  
  
  
  
>http://cxz888.xyz/posts/tech/tree_in_rust/</a></p>
</blockquote>]]></description>
</item><item>
  <title>使用 WSL2 时碰到的小问题</title>
  <link>http://cxz888.xyz/posts/tech/wsl_rust_tips/</link>
  <pubDate>Thu, 11 Aug 2022 21:02:21 &#43;0800</pubDate>
  <author>cxz888</author>
  <guid>http://cxz888.xyz/posts/tech/wsl_rust_tips/</guid>
  <description><![CDATA[<p>写这篇博客时，我因为 CS110L 的作业要求必须安装 Linux 环境。几番周折最后选择了 Windows 下的 WSL2。现在看来很不错。</p>
<p>过程中也遇到一些小坑：</p>
<ol>
<li>磁盘占用问题，<code>wsl --install</code>默认安装在 C 盘</li>
<li>代理问题 &ldquo;# Failed to establish a socket connection to proxies: [&ldquo;PROXY XXX.XXX.XXX.XXX:7890&rdquo;]&rdquo;</li>
<li>换源问题，源和系统版本不一致导致升级的包不对</li>
<li>Rust 编译报错&quot;/usr/bin/ld: cannot find Scrt1.o: No such file or directory&quot;</li>
</ol>
<p>下面一一详细记录了问题和解决方案，参考了很多网上的方法，都附了链接。</p>
<h2 id="磁盘占用问题">磁盘占用问题</h2>
<p>安装 WSL2，刚开始我用的是微软文档里写的方法，直接在命令行里<code>wsl --install</code>。后来我忽然意识到，这样安装的系统默认是在 C 盘的。而我的 C 盘早都红了，只留下 7、8 个 G 的样子。考虑到未来的使用恐怕是不足够的。</p>
<p>好嘛，只好先卸载 WSL 了。准确来说是卸载 WSL 里面安装好的 Linux 发行版。这个找网上教程即可。</p>
<blockquote>
<p>顺便一提，如果不用<code>wsl --install</code>，按照网上找到的教程，你需要手动去控制面板打开 Windows 的 WSL 选项。重启后再去手动下载 ubuntu 发行版。<code>wsl --install</code>应该是帮你把这两步都做了，但是还是需要重启的，它会在重启后才安装 Linux 发行版。</p>
</blockquote>
<p>想要自定义安装路径，就需要手动下载 ubuntu 安装包，在<a
  href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>微软 WSL2 文档</a> 中查看发行版列表。如下</p>
<p></p>
<p>如果本文附带的链接失效了，你可以自己去搜索微软的 WSL2 文档。</p>
<p>点击上图中你想要的发行版，就会开始下载。另外提一句，最上面的 Ubuntu 似乎是 20.04 版本的，不知道它和下面的 Ubuntu 20.04 有什么区别。</p>
<p>下载好的文件大概是这个样子。</p>
<p></p>
<p>直接运行它会直接通过 Microsoft Store 安装，不过我们不这么做（因为可能改不了路径）。我们把它当作压缩文件打开，比如改后缀打开，或者右键、打开方式里选压缩软件打开。内容大致如下。</p>
<p></p>
<p>里面有很多东西，不过比较大的就一个 x64 结尾，一个 ARM64 结尾。根据架构自行选择即可。</p>
<p>把这个 <code>.appx</code> 文件当作压缩文件解压。如果不行，就先把它后缀的改成 <code>.zip</code> 再解压。解压的目标位置就是你希望 Linux 发行版安装的位置。</p>
<p>现在你应该得到了一堆文件，其中应该有一个很显眼的 <code>ubuntu.exe</code>。运行它，等待安装就可以了。最后它可能会生成一个 <code>.vhdx</code> 文件，这应该就是你的 Linux 发行版系统内部所有文件的存储位置了（所以其它文件可以删了）。</p>
<p>最后，在命令行输入 <code>wsl</code>，就可以启动 Linux 系统啦。</p>
<p>参考文章：<a
  href="https://zhuanlan.zhihu.com/p/263089007?ivk_sa=1024320u"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>自定义 WSL 的安装位置，别再装到 C 盘啦</a></p>
<h2 id="代理问题">代理问题</h2>
<p>如果你挂了梯子，那么可能在 WSL 里遇到问题。你可能会看到类似于 <code># Failed to establish a socket connection to proxies: [&quot;PROXY XXX.XXX.XXX.XXX:XXXX&quot;]</code> 这样的错误。而且你会发现，在 Windows 上能访问 Google 等网站，在 WSL 上用 <code>wget</code> 等命令就无法访问。</p>
<p>此时可以先去 powershell（注意在宿主机，也就是 Windows 上）执行 <code>ipconfig</code> 查看 WSL 的 IPv4 地址。类似于下图</p>
<p></p>
<p>假设你查询到的 IP 地址是 XXX.XXX.XXX.XXX，那么就在 WSL 上修改 <code>http_proxy</code> 和 <code>https_proxy</code> 这两个环境变量。比如用<code>export</code>命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">http_proxy</span><span class="o">=</span><span class="s2">&#34;http://XXX.XXX.XXX.XXX:PORT&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">https_proxy</span><span class="o">=</span><span class="s2">&#34;http://XXX.XXX.XXX.XXX:PORT&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 PORT 是你的代理软件开放的 LAN 端口，对于 clash 而言是 7890。（2022/8/11 时）</p>
<p>注意 <code>https_proxy</code> 的值不需要是 <code>https</code>，否则未来很可能在使用 <code>curl</code> 时出现 OpenSSL 错误。</p>
<p>这个命令是每次打开 WSL 都要输的，你可以用别名来简化流程，也可以设置 /etc/profile 文件来一劳永逸。</p>
<p>而且你还需要打开你代理软件的“允许 LAN”的选项。如果你用的是 Clash for Windows，就是首页的那个 Allow LAN。</p>
<p>如果现在还不行，有可能是防火墙的问题，在控制面板-&gt;系统和安全-&gt;Windows Defender 防火墙-&gt;允许应用通过 Window 防火墙中，把你的代理软件的相关项全部打上勾。</p>
<p>现在在 WSL 里应该也可以访问 Google 了。</p>
<p>如果某一天你发现 WSL 里面代理又不好使了，可以重新在 Windows 下输入 <code>ipconfig</code> 查看 WSL 的 IP 地址。这个地址不是固定的，有可能变化。</p>
<p>参考博客：<a
  href="https://blog.lishunyang.com/2021/02/wsl2-dev-env.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>WSL 开发环境的坑（不定期更新）</a></p>
<h2 id="换源问题">换源问题</h2>
<p>换源也不是随便换的。</p>
<p>首先用命令 <code>lsb_release -a</code>，查看自己的发行版本和代号。</p>
<p>比如我用的这个是 ubuntu 20.04 代号为 <code>focal</code>。</p>
<p>那么相应的，换源时就得注意这个代号。</p>
<p>首先用 <code>sudo vim /etc/apt/sources.list</code> 打开文件（如果你不会使用 vim 就用别的文本编辑器）</p>
<p>然后删除原来的内容，输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#阿里源
</span></span><span class="line"><span class="cl">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
</span></span><span class="line"><span class="cl">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意看，其中有 <code>focal</code> 这个代号，一定要和自己版本的代号一致。</p>
<p>换完源之后别忘了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="n">sudo</span> <span class="nb">apt-get</span> <span class="n">update</span>    <span class="c"># 更新源</span>
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="nb">apt-get</span> <span class="n">upgrade</span>   <span class="c"># 更新软件包</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参考博客：<a
  href="https://blog.csdn.net/WU2629409421perfect/article/details/110881141"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Ubuntu 20.04 &amp;&amp; Ubuntu 18.04 修改 apt 源</a></p>
<h2 id="rust-编译报错">rust 编译报错</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/usr/bin/ld: cannot find Scrt1.o: No such file or directory
</span></span><span class="line"><span class="cl">/usr/bin/ld: cannot find crti.o: No such file or directory
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个可能是因为我刚开始换源没换对引发的错误。</p>
<p>总之如果你出现这个问题，可以尝试按上面操作换到正确的源上，然后更新一下试试。</p>
<p>如果不行的话，再使用 <code>sudo apt-get install libc6-dev</code> 安装软件包。这样应该能解决问题了。</p>
<p><a
  href="https://blog.csdn.net/weixin_42255281/article/details/110820663"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>usr/bin/ld: cannot find crti.o: No such file or directory</a></p>
<h2 id="总结">总结</h2>
<p>WSL2 要占用不少内存，不过使用起来体验比 VMWare 要好很多。如果你不是很在乎图形界面的话，那么推荐可以尝试一下。（其实也有在 WSL2 中使用 GUI 的方法，不过似乎要 Win11）</p>
<blockquote>
<p>版权声明：本文采用 <a
  href="http://creativecommons.org/licenses/by/4.0/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>CC BY 4.0</a> 进行许可，转载请注明出处。</p>
<p>本文链接：<a
  href="http://cxz888.xyz/posts/tech/wsl_rust_tips/"
  
  
  
  
  
>http://cxz888.xyz/posts/tech/wsl_rust_tips/</a></p>
</blockquote>]]></description>
</item></channel>
</rss>
